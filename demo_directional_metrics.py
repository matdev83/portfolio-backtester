#!/usr/bin/env python3
"""
Demo script showing enhanced directional trade statistics (All/Long/Short).
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

import pandas as pd
import numpy as np
from portfolio_backtester.trading.trade_tracker import TradeTracker
from portfolio_backtester.reporting.performance_metrics import calculate_metrics

def create_mixed_trading_scenario():
    """Create a realistic trading scenario with both long and short positions."""
    print("Creating mixed long/short trading scenario...")
    
    # Create 6 months of daily data
    dates = pd.date_range('2023-01-01', '2023-06-30', freq='D')
    tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA']
    
    # Initialize trade tracker
    tracker = TradeTracker(portfolio_value=1000000)  # $1M portfolio
    
    # Simulate weekly rebalancing with mixed long/short positions
    rebalance_dates = pd.date_range('2023-01-02', '2023-06-30', freq='W-MON')  # Weekly Monday
    
    np.random.seed(42)  # For reproducible results
    
    for i, rebal_date in enumerate(rebalance_dates):
        if rebal_date not in dates:
            continue
        
        # Create mixed portfolio with both long and short positions
        # Simulate a long/short equity strategy
        long_tickers = tickers[:3]  # First 3 tickers for long positions
        short_tickers = tickers[3:]  # Last 3 tickers for short positions
        
        # Generate weights (positive for long, negative for short)\n        long_weights = np.random.uniform(0.1, 0.3, len(long_tickers))  # 10-30% each\n        short_weights = -np.random.uniform(0.05, 0.15, len(short_tickers))  # -5% to -15% each\n        \n        # Combine weights\n        all_weights = np.concatenate([long_weights, short_weights])\n        weight_series = pd.Series(dict(zip(tickers, all_weights)))\n        \n        # Create realistic price movements\n        base_prices = [150, 300, 2500, 3000, 400, 200]  # Realistic starting prices\n        \n        # Simulate different performance for long vs short positions\n        # Long positions generally trend up, short positions trend down (profitable shorts)\n        long_trends = np.random.normal(0.02, 0.03, len(long_tickers))  # Positive trend\n        short_trends = np.random.normal(-0.015, 0.025, len(short_tickers))  # Negative trend (good for shorts)\n        \n        all_trends = np.concatenate([long_trends, short_trends])\n        current_prices = [base * (1 + trend * (i + 1)) for base, trend in zip(base_prices, all_trends)]\n        \n        # Add some volatility\n        volatility = np.random.normal(0, 0.02, len(tickers))\n        current_prices = [price * (1 + vol) for price, vol in zip(current_prices, volatility)]\n        \n        price_series = pd.Series(dict(zip(tickers, current_prices)))\n        \n        # Calculate realistic transaction costs\n        transaction_cost = 15.0  # $15 per ticker traded\n        \n        # Update positions\n        tracker.update_positions(rebal_date, weight_series, price_series, transaction_cost)\n        \n        # Simulate daily price updates for MFE/MAE tracking\n        week_end = min(rebal_date + pd.DateOffset(weeks=1), dates[-1])\n        daily_dates = pd.date_range(rebal_date, week_end, freq='D')\n        \n        for daily_date in daily_dates[1:]:  # Skip first day (already processed)\n            if daily_date in dates:\n                # Create daily price variations\n                daily_changes = np.random.normal(0, 0.015, len(tickers))  # 1.5% daily vol\n                daily_prices = [price * (1 + change) for price, change in zip(current_prices, daily_changes)]\n                daily_price_series = pd.Series(dict(zip(tickers, daily_prices)))\n                \n                # Update MFE/MAE\n                tracker.update_mfe_mae(daily_date, daily_price_series)\n                \n                # Update current prices for next iteration\n                current_prices = daily_prices\n    \n    # Close all positions at the end\n    final_prices = pd.Series(dict(zip(tickers, current_prices)))\n    tracker.close_all_positions(dates[-1], final_prices)\n    \n    return tracker

def demonstrate_directional_metrics():
    \"\"\"Demonstrate the enhanced directional trade statistics.\"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"ENHANCED DIRECTIONAL TRADE STATISTICS DEMONSTRATION\")\n    print(\"=\"*80)\n    \n    # Create mixed trading scenario\n    trade_tracker = create_mixed_trading_scenario()\n    \n    # Get comprehensive trade statistics\n    trade_stats = trade_tracker.get_trade_statistics()\n    \n    print(\"\\nüìä DIRECTIONAL TRADE SUMMARY:\")\n    print(\"-\" * 50)\n    \n    # Show summary comparison\n    summary = trade_tracker.get_directional_summary()\n    \n    summary_df = pd.DataFrame(summary).T\n    print(summary_df.round(2))\n    \n    print(\"\\nüìã DETAILED DIRECTIONAL TRADE STATISTICS:\")\n    print(\"-\" * 60)\n    \n    # Show detailed table\n    detailed_table = trade_tracker.get_trade_statistics_table()\n    if not detailed_table.empty:\n        # Display the table with better formatting\n        pd.set_option('display.max_columns', None)\n        pd.set_option('display.width', None)\n        pd.set_option('display.max_colwidth', 25)\n        \n        print(detailed_table.to_string(index=False))\n    else:\n        print(\"No trades to display.\")\n    \n    print(\"\\nüîç KEY INSIGHTS:\")\n    print(\"-\" * 30)\n    \n    # Extract key insights\n    all_trades = trade_stats.get('all_num_trades', 0)\n    long_trades = trade_stats.get('long_num_trades', 0)\n    short_trades = trade_stats.get('short_num_trades', 0)\n    \n    long_win_rate = trade_stats.get('long_win_rate_pct', 0)\n    short_win_rate = trade_stats.get('short_win_rate_pct', 0)\n    \n    long_reward_risk = trade_stats.get('long_reward_risk_ratio', 0)\n    short_reward_risk = trade_stats.get('short_reward_risk_ratio', 0)\n    \n    long_pnl = trade_stats.get('long_total_pnl_net', 0)\n    short_pnl = trade_stats.get('short_total_pnl_net', 0)\n    \n    print(f\"‚Ä¢ Total Trades: {all_trades} (Long: {long_trades}, Short: {short_trades})\")\n    print(f\"‚Ä¢ Long Position Win Rate: {long_win_rate:.1f}%\")\n    print(f\"‚Ä¢ Short Position Win Rate: {short_win_rate:.1f}%\")\n    print(f\"‚Ä¢ Long Reward/Risk Ratio: {long_reward_risk:.2f}\")\n    print(f\"‚Ä¢ Short Reward/Risk Ratio: {short_reward_risk:.2f}\")\n    print(f\"‚Ä¢ Long P&L: ${long_pnl:,.2f}\")\n    print(f\"‚Ä¢ Short P&L: ${short_pnl:,.2f}\")\n    \n    # Performance comparison\n    if long_trades > 0 and short_trades > 0:\n        print(\"\\nüìà PERFORMANCE COMPARISON:\")\n        print(\"-\" * 35)\n        \n        long_avg_pnl = trade_stats.get('long_mean_trade_pnl', 0)\n        short_avg_pnl = trade_stats.get('short_mean_trade_pnl', 0)\n        \n        better_direction = \"Long\" if long_avg_pnl > short_avg_pnl else \"Short\"\n        print(f\"‚Ä¢ Better performing direction: {better_direction} positions\")\n        print(f\"‚Ä¢ Long average trade P&L: ${long_avg_pnl:,.2f}\")\n        print(f\"‚Ä¢ Short average trade P&L: ${short_avg_pnl:,.2f}\")\n        \n        # Risk analysis\n        long_largest_loss = trade_stats.get('long_largest_loss', 0)\n        short_largest_loss = trade_stats.get('short_largest_loss', 0)\n        \n        print(f\"‚Ä¢ Long largest single loss: ${long_largest_loss:,.2f}\")\n        print(f\"‚Ä¢ Short largest single loss: ${short_largest_loss:,.2f}\")\n    \n    # Show sample trade history\n    trade_history = trade_tracker.get_trade_history_dataframe()\n    if not trade_history.empty:\n        print(\"\\nüìã SAMPLE TRADE HISTORY (First 10 trades):\")\n        print(\"-\" * 55)\n        \n        # Add direction column for clarity\n        trade_history['direction'] = trade_history['quantity'].apply(lambda x: 'Long' if x > 0 else 'Short')\n        \n        # Select key columns for display\n        display_cols = ['ticker', 'direction', 'entry_date', 'exit_date', 'duration_days', \n                       'pnl_net', 'return_net', 'is_winner']\n        \n        sample_history = trade_history[display_cols].head(10)\n        sample_history['pnl_net'] = sample_history['pnl_net'].apply(lambda x: f\"${x:,.2f}\")\n        sample_history['return_net'] = sample_history['return_net'].apply(lambda x: f\"{x:.2%}\")\n        \n        print(sample_history.to_string(index=False))\n        \n        if len(trade_history) > 10:\n            print(f\"\\n... and {len(trade_history) - 10} more trades\")\n    \n    print(\"\\n\" + \"=\"*80)\n    print(\"‚úÖ DIRECTIONAL ANALYSIS COMPLETE!\")\n    print(\"\\nThe enhanced metrics now provide detailed insights into:\")\n    print(\"‚Ä¢ Separate performance analysis for long vs short positions\")\n    print(\"‚Ä¢ Individual profit/loss statistics by direction\")\n    print(\"‚Ä¢ Reward/risk ratios for each trading direction\")\n    print(\"‚Ä¢ Largest single gains and losses by position type\")\n    print(\"‚Ä¢ Comprehensive comparison across all trade directions\")\n    print(\"=\"*80)\n    \n    return trade_stats, trade_tracker

if __name__ == \"__main__\":\n    try:\n        stats, tracker = demonstrate_directional_metrics()\n        print(\"\\nüéâ Directional metrics demo completed successfully!\")\n    except Exception as e:\n        print(f\"\\n‚ùå Demo failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)