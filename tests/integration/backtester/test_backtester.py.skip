import unittest
from typing import Optional  # Import Optional
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd

from src.portfolio_backtester.strategies import enumerate_strategies_with_params
from src.portfolio_backtester.backtester import Backtester
from src.portfolio_backtester.config_loader import GLOBAL_CONFIG
from src.portfolio_backtester.strategies import enumerate_strategies_with_params

# IMPORTANT: Mock Decorator Signature Guidelines for Future Developers
# =====================================================================
# When using multiple @patch decorators, the test method parameters must match in REVERSE ORDER:
# 
# @patch('module.ClassA')     <- This becomes the LAST parameter
# @patch('module.ClassB')     <- This becomes the SECOND-TO-LAST parameter  
# @patch('module.ClassC')     <- This becomes the FIRST parameter after 'self'
# def test_method(self, mock_class_c, mock_class_b, mock_class_a):
#
# Common mistakes that cause "missing required positional argument" errors:
# 1. Missing @patch decorators for classes that are imported/instantiated in the code under test
# 2. Wrong parameter order in test method signature (should be reverse of decorator order)
# 3. Missing mock parameters in method signature when @patch decorators are present
# 4. Incomplete test implementations that don't use the mocked objects properly
#
# For data source tests specifically:
# - Always mock the specific data source class being tested (StooqDataSource, YFinanceDataSource, etc.)
# - Mock numpy.random.seed if the Backtester constructor calls it
# - Ensure mock instances are properly configured with __name__ attributes and return values

class TestBacktester(unittest.TestCase):
    class MockArgs:
        def __init__(self):
            self.optimize_min_positions: int = 10
            self.optimize_max_positions: int = 30
            self.top_n_params: int = 3
            self.n_jobs: int = 1
            self.optuna_trials: int = 10
            self.optuna_timeout_sec: Optional[int] = 60
            self.study_name: Optional[str] = "test_study"
            self.random_seed: Optional[int] = None # Allow int or None
            self.storage_url: Optional[str] = None
            self.early_stop_patience: int = 10
            self.pruning_enabled: bool = False
            self.pruning_n_startup_trials: int = 5
            self.pruning_n_warmup_steps: int = 0
            self.pruning_interval_steps: int = 1
            self.optimizer: str = "optuna"
            self.mode: str = "backtest" # Add default mode
            self.mc_simulations: int = 1000 # Add default for MC
            self.mc_years: int = 10 # Add default for MC
            self.interactive: bool = False # Add default for interactive
            self.timeout: Optional[int] = None

    def setUp(self):
        """Set up a mock backtester and data for testing."""
        self.global_config = GLOBAL_CONFIG.copy()
        self.scenarios = [
            {
                "name": "Test_Momentum_WFO",
                "strategy": "momentum",
                "strategy_params": {
                    "lookback_months": 6,
                    "leverage": 1.0,
                    "smoothing_lambda": 0.5,
                    "long_only": True,
                    "top_decile_fraction": 0.1
                },
                "rebalance_frequency": "M",
                "position_sizer": "equal_weight",
                "transaction_costs_bps": 10,
                "train_window_months": 24,
                "test_window_months": 6,
                "optimization_metric": "Sharpe", # Added scenario-level metric
                "optimize": [
                    {
                        "parameter": "lookback_months",
                        # "metric": "Sharpe", # Metric removed from here
                        "min_value": 3,
                        "max_value": 9,
                        "step": 3
                    }
                ]
            }
        ]
        self.mock_args = self.MockArgs() # Use the class attribute
        
        dates = pd.date_range(start="2018-01-01", periods=72, freq="ME")  # 6 years of data
        tickers = self.global_config["universe"] + [self.global_config["benchmark"]]
        self.mock_data = pd.DataFrame(
            np.random.randn(72, len(tickers)) / 100 + 0.001,
            index=dates,
            columns=tickers
        )
        pass


    @patch('src.portfolio_backtester.backtester.Backtester._get_data_source')
    @patch('numpy.random.seed')
    def test_init_basic_attributes(self, mock_np_seed, mock_get_data_source):
        mock_get_data_source.return_value = "mock_data_source_instance"
        args = self.MockArgs()
        backtester = Backtester(self.global_config, self.scenarios, args, random_state=123)

        self.assertEqual(backtester.global_config, self.global_config)
        self.assertIn("optimizer_parameter_defaults", backtester.global_config) # Check if defaults are added
        self.assertEqual(backtester.scenarios, self.scenarios)
        self.assertEqual(backtester.args, args)
        self.assertEqual(backtester.data_source, "mock_data_source_instance")
        self.assertEqual(backtester.results, {})
        self.assertEqual(backtester.n_jobs, args.n_jobs)
        self.assertEqual(backtester.early_stop_patience, 10) # Default from MockArgs or Backtester default
        mock_np_seed.assert_called_with(123)

    @patch('src.portfolio_backtester.backtester.Backtester._get_data_source')
    @patch('numpy.random.seed')
    @patch('numpy.random.randint')
    def test_init_random_seed_generation(self, mock_np_randint, mock_np_seed, mock_get_data_source):
        mock_np_randint.return_value = 42 # Mock the generated seed value
        args = self.MockArgs()
        args.random_seed = None # Ensure it's None to trigger generation

        backtester = Backtester(self.global_config, self.scenarios, args, random_state=None) # Explicitly pass None

        mock_np_randint.assert_called_once_with(0, 2**31 - 1)
        mock_np_seed.assert_called_with(42)
        self.assertEqual(backtester.random_state, 42)

    @patch('src.portfolio_backtester.backtester.Backtester._get_data_source')
    @patch('numpy.random.seed')
    def test_init_provided_random_seed(self, mock_np_seed, mock_get_data_source):
        args = self.MockArgs()
        args.random_seed = 777 # Provide a seed via args

        # Test when random_state is passed directly to constructor
        backtester_direct_seed = Backtester(self.global_config, self.scenarios, args, random_state=777)
        mock_np_seed.assert_called_with(777)
        self.assertEqual(backtester_direct_seed.random_state, 777)

    @patch('src.portfolio_backtester.backtester.Backtester._get_data_source')
    def test_init_job_settings_from_args(self, mock_get_data_source):
        args = self.MockArgs()
        args.n_jobs = 4
        args.early_stop_patience = 20

        backtester = Backtester(self.global_config, self.scenarios, args)

        self.assertEqual(backtester.n_jobs, 4)
        self.assertEqual(backtester.early_stop_patience, 20)

    # CRITICAL FIX: This test was failing with "missing required positional argument" error
    # because the @patch decorator for StooqDataSource was missing. The Backtester._get_data_source()
    # method imports and instantiates StooqDataSource, so it MUST be mocked.
    # Parameter order: mock_np_seed (last @patch), mock_stooq_data_source_class (first @patch)
    @patch('src.portfolio_backtester.data_sources.stooq_data_source.StooqDataSource')
    @patch('numpy.random.seed')
    def test_get_data_source_stooq(self, mock_np_seed, mock_stooq_data_source_class):
        mock_stooq_data_source_class.__name__ = 'StooqDataSource'
        mock_instance = MagicMock()
        mock_stooq_data_source_class.return_value = mock_instance

        config = self.global_config.copy()
        config["data_source"] = "stooq"
        args = self.MockArgs()
        # Temporarily patch np.random.seed for Backtester instantiation
        with patch('numpy.random.seed'):
            backtester = Backtester(config, self.scenarios, args)

        # _get_data_source is called in __init__, so we check the instance attribute
        self.assertEqual(backtester.data_source, mock_instance)
        mock_stooq_data_source_class.assert_called_once_with()


    # CRITICAL FIX: Similar to the stooq test, this was missing the YFinanceDataSource @patch decorator.
    # The Backtester._get_data_source() method dynamically imports and instantiates data source classes,
    # so ALL data source classes that could be instantiated must be mocked to avoid import/instantiation errors.
    @patch('src.portfolio_backtester.data_sources.yfinance_data_source.YFinanceDataSource')
    @patch('numpy.random.seed')
    def test_get_data_source_yfinance(self, mock_np_seed, mock_yfinance_data_source_class):
        mock_yfinance_data_source_class.__name__ = 'YFinanceDataSource'
        mock_instance = MagicMock()
        mock_yfinance_data_source_class.return_value = mock_instance

        config = self.global_config.copy()
        config["data_source"] = "yfinance"
        args = self.MockArgs()
        with patch('numpy.random.seed'):
            backtester = Backtester(config, self.scenarios, args)

        self.assertEqual(backtester.data_source, mock_instance)
        mock_yfinance_data_source_class.assert_called_once_with()

    @patch('src.portfolio_backtester.data_sources.hybrid_data_source.HybridDataSource') # Default
    @patch('numpy.random.seed')
    def test_get_data_source_default_to_hybrid(self, mock_np_seed, mock_hybrid_data_source_class):
        mock_hybrid_data_source_class.__name__ = 'HybridDataSource'
        mock_instance = MagicMock()
        mock_hybrid_data_source_class.return_value = mock_instance

        config = self.global_config.copy()
        # Don't set data_source, should default to hybrid
        args = self.MockArgs()
        with patch('numpy.random.seed'):
            backtester = Backtester(config, self.scenarios, args)

        self.assertEqual(backtester.data_source, mock_instance)
        mock_hybrid_data_source_class.assert_called_once_with(prefer_stooq=True)

    @patch('src.portfolio_backtester.data_sources.hybrid_data_source.HybridDataSource')
    @patch('numpy.random.seed')
    def test_get_data_source_hybrid(self, mock_np_seed, mock_hybrid_data_source_class):
        mock_hybrid_data_source_class.__name__ = 'HybridDataSource'
        mock_instance = MagicMock()
        mock_hybrid_data_source_class.return_value = mock_instance

        config = self.global_config.copy()
        config["data_source"] = "hybrid"
        args = self.MockArgs()
        with patch('numpy.random.seed'):
            backtester = Backtester(config, self.scenarios, args)

        self.assertEqual(backtester.data_source, mock_instance)
        mock_hybrid_data_source_class.assert_called_once_with(prefer_stooq=True)

    def test_get_data_source_unsupported(self):
        config = self.global_config.copy()
        config["data_source"] = "unsupported_source"
        args = self.MockArgs()
        with patch('numpy.random.seed'):
            with self.assertRaisesRegex(ValueError, "Unsupported data source: unsupported_source"):
                Backtester(config, self.scenarios, args)

    # Tests for _get_strategy
    def test_get_strategy_valid(self):
        params = {"lookback": 10}

        # Need a backtester instance to call _get_strategy on
        # Mock _get_data_source to simplify Backtester instantiation
        with patch.object(Backtester, '_get_data_source', return_value=MagicMock()):
            args = self.MockArgs()
            backtester = Backtester(self.global_config, self.scenarios, args)

        strategy_instance = backtester._get_strategy("momentum", params)

        # Use type-based comparison instead of exact object equality
        from src.portfolio_backtester.strategies.momentum_strategy import MomentumStrategy
        self.assertIsInstance(strategy_instance, MomentumStrategy)
        # Check that the strategy was initialized with the correct parameters
        # Parameters are stored directly in strategy_config, not in a nested dict
        for key, value in params.items():
            self.assertEqual(strategy_instance.strategy_config[key], value)

    def test_get_strategy_vams_momentum(self):
        params = {"alpha": 0.5}
        with patch.object(Backtester, '_get_data_source', return_value=MagicMock()):
            args = self.MockArgs()
            backtester = Backtester(self.global_config, self.scenarios, args)
        strategy_instance = backtester._get_strategy("vams_momentum", params)
        
        # Use type-based comparison instead of exact object equality
        from src.portfolio_backtester.strategies.vams_momentum_strategy import VAMSMomentumStrategy
        self.assertIsInstance(strategy_instance, VAMSMomentumStrategy)
        # Check that the strategy was initialized with the correct parameters
        # Parameters are stored directly in strategy_config, not in a nested dict
        for key, value in params.items():
            self.assertEqual(strategy_instance.strategy_config[key], value)

    def test_get_strategy_vams_no_downside(self):
        params = {}
        with patch.object(Backtester, '_get_data_source', return_value=MagicMock()):
            args = self.MockArgs()
            backtester = Backtester(self.global_config, self.scenarios, args)
        strategy_instance = backtester._get_strategy("vams_no_downside", params)
        
        # Use type-based comparison instead of exact object equality
        from src.portfolio_backtester.strategies.vams_no_downside_strategy import VAMSNoDownsideStrategy
        self.assertIsInstance(strategy_instance, VAMSNoDownsideStrategy)
        # Check that the strategy was initialized with the correct parameters
        # Parameters are stored directly in strategy_config, not in a nested dict
        # For empty params, just verify the strategy instance was created successfully
        if params:
            for key, value in params.items():
                self.assertEqual(strategy_instance.strategy_config[key], value)

    def test_get_strategy_unsupported(self):
        params = {}
        with patch.object(Backtester, '_get_data_source', return_value=MagicMock()):
            args = self.MockArgs()
            backtester = Backtester(self.global_config, self.scenarios, args)

        with self.assertRaisesRegex(ValueError, "Unsupported strategy: non_existent_strategy"):
            backtester._get_strategy("non_existent_strategy", params)

if __name__ == '__main__':
    unittest.main()