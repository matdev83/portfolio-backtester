from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict

import numpy as np
import pandas as pd

if TYPE_CHECKING:
    pass  # For type hinting if needed


class BaseTakeProfit(ABC):
    """
    Abstract base class for take-profit handlers.

    Take profit handlers monitor positions for favorable price movements
    and automatically close positions when profit targets are reached.
    """

    def __init__(
        self, strategy_config: Dict[str, Any], take_profit_specific_config: Dict[str, Any]
    ):
        """
        Initializes the take-profit handler.

        Args:
            strategy_config: The overall configuration for the strategy.
            take_profit_specific_config: Configuration specific to this take-profit handler,
                                        e.g., {"type": "AtrBasedTakeProfit", "atr_length": 14, ...}.
        """
        self.strategy_config = strategy_config
        self.take_profit_specific_config = take_profit_specific_config

    @abstractmethod
    def calculate_take_profit_levels(
        self,
        current_date: pd.Timestamp,
        asset_ohlc_history: pd.DataFrame,
        current_weights: pd.Series,
        entry_prices: pd.Series,
    ) -> pd.Series:
        """
        Calculates the take-profit price levels for each asset.

        Args:
            current_date: The current date for which to calculate take profit levels.
            asset_ohlc_history: DataFrame of historical OHLCV data for all assets up to current_date.
            current_weights: Series of current weights of assets in the portfolio.
                             Positive for long, negative for short, zero if no position.
            entry_prices: Series of entry prices for the current positions. NaN if no position
                          or entry price is not tracked.

        Returns:
            A pandas Series with asset tickers as index and take-profit price levels as values.
            NaN if no take-profit is applicable for an asset.
        """
        pass

    @abstractmethod
    def apply_take_profit(
        self,
        current_date: pd.Timestamp,
        current_asset_prices: pd.Series,
        target_weights: pd.Series,
        entry_prices: pd.Series,
        take_profit_levels: pd.Series,
    ) -> pd.Series:
        """
        Adjusts target weights if take-profit conditions are met.

        Args:
            current_date: The specific date for which the take profit is being checked.
            current_asset_prices: Series of current prices (e.g., 'Close') for assets, for current_date.
            target_weights: The target weights proposed by the main strategy logic.
            entry_prices: Series of entry prices for current positions.
            take_profit_levels: Series of take-profit price levels calculated by `calculate_take_profit_levels`.

        Returns:
            A pandas Series with adjusted weights after applying take-profit logic.
            Assets hitting their take-profit should have their weights set to 0.
        """
        pass


class NoTakeProfit(BaseTakeProfit):
    """
    A take-profit handler that does not implement any take-profit logic.
    This is the default implementation that never emits take-profit signals.
    """

    def calculate_take_profit_levels(
        self,
        current_date: pd.Timestamp,
        asset_ohlc_history: pd.DataFrame,
        current_weights: pd.Series,
        entry_prices: pd.Series,
    ) -> pd.Series:
        return pd.Series(np.nan, index=current_weights.index)

    def apply_take_profit(
        self,
        current_date: pd.Timestamp,
        current_asset_prices: pd.Series,
        target_weights: pd.Series,
        entry_prices: pd.Series,
        take_profit_levels: pd.Series,
    ) -> pd.Series:
        return target_weights


class AtrBasedTakeProfit(BaseTakeProfit):
    """
    A take-profit handler that uses Average True Range (ATR) to set take-profit levels.

    For long positions: Take profit when price rises above entry_price + (ATR * atr_multiple)
    For short positions: Take profit when price falls below entry_price - (ATR * atr_multiple)
    """

    def __init__(self, strategy_config: dict, take_profit_specific_config: dict):
        super().__init__(strategy_config, take_profit_specific_config)
        self.atr_length = self.take_profit_specific_config.get("atr_length", 14)
        self.atr_multiple = self.take_profit_specific_config.get("atr_multiple", 2.0)

    def calculate_take_profit_levels(
        self,
        current_date: pd.Timestamp,
        asset_ohlc_history: pd.DataFrame,
        current_weights: pd.Series,
        entry_prices: pd.Series,
    ) -> pd.Series:
        # Fast ATR calculation using optimized service
        atr_values_for_date = calculate_atr_fast(asset_ohlc_history, current_date, self.atr_length)
        take_profit_levels = pd.Series(np.nan, index=current_weights.index)

        # Only consider assets with open positions and valid entry prices
        open_mask = (
            (current_weights != 0) & (~pd.isna(entry_prices)) & (~pd.isna(atr_values_for_date))
        )
        long_mask = open_mask & (current_weights > 0)
        short_mask = open_mask & (current_weights < 0)

        # Vectorized take profit level calculation (opposite logic from stop loss)
        # For long positions: take profit when price goes UP by ATR multiple
        take_profit_levels[long_mask] = entry_prices[long_mask] + (
            atr_values_for_date[long_mask] * self.atr_multiple
        )
        # For short positions: take profit when price goes DOWN by ATR multiple
        take_profit_levels[short_mask] = entry_prices[short_mask] - (
            atr_values_for_date[short_mask] * self.atr_multiple
        )

        return take_profit_levels

    def apply_take_profit(
            tickers: list = []
            if hasattr(asset_ohlc_history, "columns"):
                if (
                    isinstance(asset_ohlc_history.columns, pd.MultiIndex)
                    and "Ticker" in asset_ohlc_history.columns.names
                ):
                    tickers = list(asset_ohlc_history.columns.get_level_values("Ticker").unique())
                else:
                    tickers = list(asset_ohlc_history.columns)
            return pd.Series(np.nan, index=tickers)

        cache_key = (str(current_date), self.atr_length, len(asset_ohlc_history))
        if cache_key in self._atr_cache:
            cached_result = self._atr_cache[cache_key]
            return cached_result

        ohlc_data = asset_ohlc_history[asset_ohlc_history.index <= current_date]
        if len(ohlc_data) < self.atr_length:
            tickers_list: list = []
            if hasattr(asset_ohlc_history, "columns"):
                if (
                    isinstance(asset_ohlc_history.columns, pd.MultiIndex)
                    and "Ticker" in asset_ohlc_history.columns.names
                ):
                    tickers_list = list(
                        asset_ohlc_history.columns.get_level_values("Ticker").unique()
                    )
                else:
                    tickers_list = list(asset_ohlc_history.columns)
            result_empty = pd.Series(np.nan, index=tickers_list)
            self._atr_cache[cache_key] = result_empty
            return result_empty

        if isinstance(ohlc_data.columns, pd.MultiIndex) and "Field" in ohlc_data.columns.names:
            tickers = list(ohlc_data.columns.get_level_values("Ticker").unique())
            highs = ohlc_data.xs("High", level="Field", axis=1)
            lows = ohlc_data.xs("Low", level="Field", axis=1)
            closes = ohlc_data.xs("Close", level="Field", axis=1)
            prev_closes = closes.shift(1)

            tr1 = highs - lows
            tr2 = (highs - prev_closes).abs()
            tr3 = (lows - prev_closes).abs()
            true_range = np.fmax(tr1, np.fmax(tr2, tr3))

            atr = (
                pd.DataFrame(true_range, index=highs.index, columns=highs.columns)
                .rolling(window=self.atr_length, min_periods=self.atr_length)
                .mean()
            )

            if current_date in atr.index:
                atr_today = atr.loc[current_date]
                if isinstance(atr_today, pd.Series):
                    result_series = atr_today
                else:
                    result_series = pd.Series(np.nan, index=tickers)
            else:
                result_series = pd.Series(np.nan, index=tickers)
            result_final = result_series
        else:
            # Fallback for simple price data without OHLC structure
            closes = ohlc_data
            returns = closes.pct_change(fill_method=None)
            rolling_std = returns.rolling(window=self.atr_length, min_periods=self.atr_length).std()

            if current_date in closes.index and current_date in rolling_std.index:
                current_prices = closes.loc[current_date]
                std_today = rolling_std.loc[current_date]
                atr_today = current_prices * std_today
                if isinstance(atr_today, pd.Series):
                    result_final = atr_today
                else:
                    result_final = pd.Series(np.nan, index=closes.columns)
            else:
                result_final = pd.Series(np.nan, index=closes.columns)

        self._atr_cache[cache_key] = result_final
        return result_final.astype(float)

    def apply_take_profit(
        self,
        current_date: pd.Timestamp,
        current_asset_prices: pd.Series,
        target_weights: pd.Series,
        entry_prices: pd.Series,
        take_profit_levels: pd.Series,
    ) -> pd.Series:
        # Vectorized take profit application
        adjusted_weights = target_weights.copy()
        valid_mask = (
            (~pd.isna(take_profit_levels))
            & (target_weights != 0)
            & (~pd.isna(current_asset_prices))
        )

        # Take profit conditions (opposite logic from stop loss)
        # Long positions: take profit when current price >= take profit level (favorable move up)
        long_mask = valid_mask & (target_weights > 0) & (current_asset_prices >= take_profit_levels)
        # Short positions: take profit when current price <= take profit level (favorable move down)
        short_mask = (
            valid_mask & (target_weights < 0) & (current_asset_prices <= take_profit_levels)
        )

        adjusted_weights[long_mask | short_mask] = 0.0
        return adjusted_weights
